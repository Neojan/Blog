
## 第7章 SRP：单一职责原则


任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。

不过，这里的“用户”和“系统利益相关者”在用词上也并不完全准确，它们很有可能指的是一个或多个用户和利益相关者，只要这些人希望对系统进行的变更是相似的，就可以归为一类——一个或多个有共同需求的人。在这里，我们将其称为行为者（actor）。

**任何一个软件模块都应该只对某一类行为者负责**。

用＜I＞标记的类代表接口，用＜DS＞标记的则代表数据结构；开放箭头指代的是使用关系，闭合箭头则指代了实现与继承关系。


## 第8章 OCP：开闭原则

**设计良好的计算机软件应该易于扩展，同时抗拒修改。**

示例：

![[开闭原则图例.png]]

用＜I＞标记的类代表接口，用＜DS＞标记的则代表数据结构；开放箭头指代的是使用关系，闭合箭头则指代了实现与继承关系。

Presenter：展示层

Interactor：业务逻辑层

Controler：控制层

这里的设计原则：如果A组件不想被B组件上发生的修改所影响，那么就应该让B组件依赖于A组件。

Interactor是最高层的抽象，所以它被保护得最严密，而Presenter比View的层级高，但比Controller和Interactor的层级低。

依赖方向控制：FinancialReportGenerator和FinancialDataMapper之间的FinancialDataGateway接口是为了反转Interactor与Database之间的依赖关系而产生的。同样的，FinancialReportPresenter接口与两个View接口之间也类似于这种情况。

信息隐藏：FinancialReportRequester接口的作用则完全不同，它的作用是保护FinancialReportController不过度依赖于Interactor的内部细节。如果没有这个接口，则Controller将会传递性地依赖于FinancialEntities。这种传递性依赖违反了“软件系统不应该依赖其不直接使用的组件”这一基本原则。所以，虽然我们的首要目的是为了让Interactor屏蔽掉发生在Controller上的修改，但也需要通过隐藏Interactor内部细节的方法来让其屏蔽掉来自Controller的依赖。


## 第9章 LSP：里氏替换原则

这里需要的是一种可替换性：如果对于每个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在用o2替换o1时行为保持不变，我们就可以将S称为T的子类型。

## 第10章 ISP：接口隔离原则

任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。

![[接口隔离原则.png]]

![[接口隔离原则2.png]]

## 第11章 DIP：依赖反转原则

依赖反转原则（DIP）主要想告诉我们的是，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。

我们每次修改抽象接口的时候，一定也会去修改对应的具体实现。但反过来，当我们修改具体实现时，却很少需要去修改相应的抽象接口。所以我们可以认为接口比实现更稳定。

**应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。**

**不要在具体实现类上创建衍生类。**

**不要覆盖（override）包含具体实现的函数。**

应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。

### 工厂模式

![[利用抽象工厂模式来管理依赖关系.png]]

图中间的那条曲线代表了软件架构中的抽象层与具体实现层的边界。在这里，所有跨越这条边界源代码级别的依赖关系都应该是
单向的，即具体实现层依赖抽象层。这条曲线将整个系统划分为两部分组件：抽象接口与其具体实现。抽象接口组件中包含了应用的所有高阶业务规则，而具体实现组件中则包括了所有这些业务规则所需要做的具体操作及其相关的细节信息。

请注意，这里的控制流跨越架构边界的方向与源代码依赖关系跨越该边界的方向正好相反，源代码依赖方向永远是控制流方向的反转——这就是DIP被称为依赖反转原则的原因。


绝大部分系统中都至少存在一个具体实现组件——我们一般称之为main组件，因为它们通常是main函数[5]所在之处。在图中，main函数应该负责创建ServiceFactoryImpl实例，并将其赋值给类型为ServiceFactory的全局变量，以便让Application类通过这个全局变量来进行相关调用。

## 第14章 组件耦合

### 无依赖环原则

组件依赖关系图中不应该出现环。消除循环依赖.

### 稳定依赖原则SDP

依赖关系必须要指向更稳定的方向

#### 稳定性指标

位置稳定性（positional stability）。
Fan-in：入向依赖，这个指标指代了组件外部类依赖于组件内部类的数量。
Fan-out：出向依赖，这个指标指代了组件内部类依赖于组件外部类的数量。

I：不稳定性，I=Fan-out/（Fan-in+Fan-out）。该指标的范围是[0,1],I=0意味着组件是最稳定的，I=1意味着组件是最不稳定的。

这里可以深入理解为什么要依赖与抽象，因为抽象是稳定的！

### 稳定抽象原则SAP

一个组件的抽象化程度应该与其稳定性保持一致。

#### 衡量抽象化程度

假设A指标是对组件抽象化程度的一个衡量，它的值是组件中抽象类与接口所占的比例。那么：
Nc：组件中类的数量。
Na：组件中抽象类和接口的数量。
A：抽象程度，A=Na÷Nc。
A指标的取值范围是从0到1，值为0代表组件中没有任何抽象类，值为1就意味着组件中只有抽象类。

## 第17章 划分边界

软件架构设计本身就是一门划分边界的艺术。边界的作用是将软件分割成各种元素，以便约束边界两侧之间的依赖关系。

其实就是注意抽象与实现分离

![[划分数据库边界.png]]

通过在这两个组件之间画边界线，并且让箭头指向BusinessRules组件，我们现在可以很容易地明白为什么BusinessRules组件可以使用任何一种数据库。在这里，Database组件可以被替换为多种实现，BusinessRules组件并不需要知道这件事。

所以，边界线也应该沿着系统的变更轴来画。也就是说，位于边界线两侧的组件应该以不同原因、不同速率变化着。
一个系统的GUI与业务逻辑的变更原因、变更速率显然是不同的，所以二者中间应该有一条边界线。同样的，一个系统的业务逻辑与依赖注入框架之间的变更原因和变更速度也会不同，它们之间也应该画边界线。

这其实就是单一职责原则（SRP）的具体实现，SRP的作用就是告诉我们应该在哪里画边界线。


为了在软件架构中画边界线，我们需要先将系统分割成组件，其中一部分是系统的核心业务逻辑组件，而另一部分则是与核心业务逻辑无关但负责提供必要功能的插件。然后通过对源代码的修改，让这些非核心组件依赖于系统的核心业务逻辑组件。

其实，这也是一种对依赖反转原则（DIP）和稳定抽象原则（SAP）的具体应用，依赖箭头应该由底层具体实现细节指向高层抽象的方向。

## 第19章 策略与层次

架构设计的工作常常需要将组件重排组合成为一个有向无环图。图中的每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之间的依赖关系，它们将不同级别的组件链
接起来。

这里提到的依赖关系是源码层次上的、编译期的依赖关系。这在Java语言中就是指import语句，在C#语言中就是指using语句，在Ruby语言中就是指require语句。这里的依赖关系都是在编译过程中所必需的。

在一个设计良好的架构中，依赖关系的方向通常取决于它们所关联的组件层次。一般来说，低层组件被设计为依赖于高层组件。

> 层次（Level）

我们对“层次”是严格按照“输入与输出之间的距离”来定义的。也就是说，一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的策略在系统中的层次是最低的。

![[层次-加密接口.png]]

ConsoleReader和ConsoleWriter都属于具体类。由于它们与输入/输出最近，因此属于低层组件。这个架构将高层的加密策略与低层的输入/输出策略解耦了。也就是说，当输入/输出部分的策略发生变更时，它们不太可能会影响加密部分的策略。

## 第21章 尖叫的软件架构

### 架构设计的核心目标


一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以在脱离框架、工具以及使用环境的情况下完整地描述用例。这就好像一个住宅建筑设计的首要目标应该是满足住宅的使用需求，而不是确保一定要用砖来构建这个房子。架构师应该花费很多精力来确保该架构的设计在满足用例需要的情况下，尽可能地允许用户能自由地选择建筑材料（砖头、石料或者木材）。

而且，良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架、数据库、Web服务以及其他与环境相关的工具。框架应该是一个可选项，良好的架构设计应该允许用户在项目后期再决定是否采用Rails、Spring、Hibernate、Tomcat、MySQL这些工具。同时，良好的架构设计还应该让我们很容易改变这些决定。总之，良好的架构设计应该只关注用例，并能将它们与其他的周边因素隔离。


一个系统的架构应该着重于展示系统本身的设计，而并非该系统所使用的框架。


## 第22章 整洁架构

![[整洁架构.png]]

同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外层圆代表的是机制，
内层圆代表的是策略。

当然这其中有一条贯穿整个架构设计的规则，即它的依赖关系规则：

> **源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。**


换句话说，就是任何属于内层圆中的代码都不应该牵涉外层圆中的代码，尤其是内层圆中的代码不应该引用外层圆中代码所声明的名字，包括函数、类、变量以及一切其他有命名的软件实体。

同样的道理，外层圆中使用的数据格式也不应该被内层圆中的代码所使用，尤其是当数据格式是由外层圆的框架所生成时。总之，我们不应该让外层圆中发生的任何变更影响到内层圆的代码。

### 业务实体

业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。

如果我们在写的不是一个大型系统，而是一个单一应用的话，那么我们的业务实体就是该应用的业务对象。这些对象封装了该应用中最通用、最高层的业务逻辑，它们应该属于系统中最不容易受外界影响而变动的部分。例如，一个针对页面导航方式或者安全问题的修改不应该触及这些对象，一个针对应用在运行时的行为所做的变更也不应该影响业务实体。

### 用例

软件的用例层中通常包含的是特定应用场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。这些用例引导了数据在业务实体之间的流入/流出，并指挥着业务实体利用其中的关键业务逻辑来实现用例的设计目标。

我们既不希望在这一层所发生的变更影响业务实体，同时也不希望这一层受外部因素（譬如数据库、UI、常见框架）的影响。用例层应该与它们都保持隔离。

然而，我们知道应用行为的变化会影响用例本身，因此一定会影响用例层的代码。因为如果一个用例的细节发生了变化，这一层中的某些代码自然要受到影响。

### 接口适配器

软件的接口适配器层中通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便操作的格式，转化成外部系统（譬如数据库以及Web）最方便操作的格式。例如，这一层中应该包含整个GUI MVC框架。展示器、视图、控制器都应该属于接口适配器层。而模型部分则应该由控制器传递给用例，再由用例传回展示器和视图。

同样的，这一层的代码也会负责将数据从对业务实体与用例而言最方便操作的格式，转化为对所采用的持久性框架（譬如数据库）最方便的格式。总之，在从该层再往内的同心圆中，其代码就不应该依赖任何数据库了。譬如说，如果我们采用的是SQL数据库，那么所有的SQL语句都应该被限制在这一层的代码中——而且是仅限于那些需要操作数据库的代码。

当然，这一层的代码也会负责将来自外部服务的数据转换成系统内用例与业务实体所需的格式。

### 框架与驱动程序

图22.1中最外层的模型层一般是由工具、数据库、Web框架等组成的。在这一层中，我们通常只需要编写一些与内层沟通的黏合性代码。

框架与驱动程序层中包含了所有的实现细节。Web是一个实现细节，数据库也是一个实现细节。我们将这些细节放在最外层，这样它们就很难影响到其他层了。

### 只有四层吗

图22.1中所显示的同心圆只是为了说明架构的结构，真正的架构很可能会超过四层。并没有某个规则约定一个系统的架构有且只能有四层。然而，这其中的依赖关系原则是不变的。也就是说，源码层面的依赖关系一定要指向同心圆的内侧。**层次越往内，其抽象和策略的层次越高，同时软件的抽象程度就越高，其包含的高层策略就越多。最内层的圆中包含的是最通用、最高层的策略，最外层的圆包含的是最具体的实现细节。**

### 跨越边界

在图22.1的右下侧，我们示范的是在架构中跨边界的情况。具体来说就是控制器、展示器与下一层的用例之间的通信过程。请注意这里控制流的方向：它从控制器开始，穿过用例，最后执行展示器的代码。但同时我们也该注意到，源码中的依赖方向却都是向内指向用例的。

这里，我们通常采用依赖反转原则（DIP）来解决这种相反性。例如，在Java这一类的语言中，可以通过调整代码中的接口和继承关系，利用源码中的依赖关系来限制控制流只能在正确的地方跨越架构边界。

假设某些用例代码需要调用展示器，这里一定不能直接调用，因为这样做会违反依赖关系原则：内层圆中的代码不能引用其外层的声明。我们需要让业务逻辑代码调用一个内层接口（图22.1中的“用例输出端”），并让展示器来负责实现这个接口。我们可以采用这种方式跨越系统中所有的架构边界。利用动态多态技术，我们将源码中的依赖关系与控制流的方向进行反转。不管控制流原本的方向如何，我们都可以让它遵守架构的依赖关系规则。

### 哪些数据会跨越边界

一般来说，会跨越边界的数据在数据结构上都是很简单的。如果可以的话，我们会尽量采用一些基本的结构体或简单的可传输数据对象。或者直接通过函数调用的参数来传递数据。另外，我们也可以将数据放入哈希表，或整合成某种对象。这里最重要的是这个跨边界传输的对象应该有一个独立、简单的数据结构。总之，不要投机取巧地直接传递业务实体或数据库记录对象。同时，这些传递的数据结构中也不应该存在违反依赖规则的依赖关系。

例如，很多数据库框架会返回一个便于查询的结果对象，我们称之为“行结构体”。这个结构体不应该跨边界向架构的内层传递。因为这等于让内层的代码引用外层代码，违反依赖规则。

因此，当我们进行跨边界传输时，一定要采用内层最方便使用的形式。

### 一个常见的应用场景

接下来，我们将会在图22.2中看到一个基于Web的、使用数据库的Java系统。在该系统中，Web 服务器会从用户那里收集信息，并将它们交给左上角的Controller。然后，Controller将这些信息数据包装成一个简单的Java对象，并让该对象穿越InputBoundary被传递到UseCaseInteractor。接下来，我们会让UseCaseInteractor解析数据 ， 并 通 过 它 来 控 制 与 Entities 的 交 互 。 同 时 ， 我 们 还 会 用DataAccessInterface 将Entities需要用到的数据从Database加载到内存中。随后，UseCaseInteractor会负责从Entities收集数据，并将OutputData组装成另一个简单的Java对象。最后，OutputData会穿越OutputBoundary被传递给Presenter。

图中的“使用”关系（开放箭头），它和控制流方向是一致的；而“继承”关系（闭合箭头）则与之相反，它反映的是我们对开闭原则的应用，通过调整依赖关系，可以保证底层细节的变更不会影响到高层策略组件。

![[一个基于Web的、使用数据库的常见Java程序.png]]

接下来，Presenter的任务是将OutputData重新打包成可展示的ViewModel，这也是一个简单的Java对象。ViewModel中基本上只包含字符串和一些View都会用到的开关数据。同时，OutputData中可能会包含一些Date对象，Presenter会将其格式化成可对用户展示的字符串，并将其填充到ViewModel中。同理，Currency对象和其他业务相关的数据也会经历类似的操作。如你所见，Button和MenuItems的命名定义位于ViewModel中，并且其中还包括了用于告知View层Button和MenuItems是否可用的开关数据。

我们可以看出，View除了将ViewModel中的数据转换成HTML格式之外，并没有其他功能。

最后，读者必须注意一下这里的依赖关系方向。所有跨边界的依赖线都是指向内的，这很好地遵守了架构的依赖关系规则。

## 第23章 展示器和谦卑对象

在第22章中，我们引入了展示器（presenter）的概念，展示器实际上是采用谦卑对象（humble object）模式的一种形式，这种设计模式可以很好地帮助识别和保护系统架构的边界。事实上，第22章所介绍的整洁架构中就充满了大量谦卑对象的实现体。

谦卑对象模式最初的设计目的是帮助单元测试的编写者区分容易测试的行为与难以测试的行为，并将它们隔离。其设计思路非常简单，就是将这两类行为拆分成两组模块或类。其中一组模块被称为谦卑（Humble）组，包含了系统中所有难以测试的行为，而这些行为已经被简化到不能再简化了。另一组模块则包含了所有不属于谦卑对象的行为。

例如，GUI通常是很难进行单元测试的，因为让计算机自行检视屏幕内容，并检查指定元素是否出现是非常难的事情。然而，GUI中的大部分行为实际上是很容易被测试的。这时候，我们就可以利用谦卑对象模式将GUI的这两种行为拆分成展示器与视图两部分。

在每个系统架构的边界处，都有可能发现谦卑对象模式的存在。因为跨边界的通信肯定需要用到某种简单的数据结构，而边界会自然而然地将系统分割成难以测试的部分与容易测试的部分，所以通过在系统的边界处运用谦卑对象模式，我们可以大幅地提高整个系统的可测试性。


## 第27章 服务：宏观与微观

面向服务的“架构”以及微服务“架构”近年来非常流行，其中的原因如下：

服务之间似乎是强隔离的，但是下文我们会讲到，并不完全是这样。

服务被认为是支持独立开发和部署的，同样，下文我们也会讲到，并不完全是这样。

服务之间的确在变量层面做到了彼此隔离。然而，它们之间还是可能会因为处理器内的共享资源，或者通过网络共享资源而彼此耦合的。另外，任何形式的共享数据行为都会导致强耦合。

例如，如果给服务之间传递的数据记录中增加了一个新字段，那么每个需要操作这个字段的服务都必须要做出相应的变更，服务之间必须对这条数据的解读达成一致。因此其实这些服务全部是强耦合于这条数据结构的，因此它们是间接彼此耦合的。

解耦合谬论已经说明拆分服务并不意味着这些服务可以彼此独立开发、部署和运维。如果这些服务之间以数据形式或者行为形式相耦合，那么它们的开发、部署和运维也必须彼此协调来进行。
