# 性能

## 性能优化的方法

1.  测量程序当前的状况，距离我们的目标还有多远，做到心中有数。
2. 分析我们的程序，查找到性能瓶颈，一般来讲 20%的代码占用了 80%的时间。
3. 修改程序
4. 重新测试，验证我们优化的结果。
5. 如果满足要求，就停止优化，过度的优化，有可能导致代码可读性的下降；如果不满足
要求，我们需要分析测量结果，查找瓶颈。

主要分为
1. 性能的评测
2. shell 脚本的性能优化
3. C 和 C++程序性能优化

## 性能的评测

程序性能的问题，有很多原因，我们需要找到性能的瓶颈，来对症下药：
1. 程序的运算量很大，导致 CPU 过于繁忙， CPU 是瓶颈。
2. 程序需要做大量的 I/O，读写文件、内存操作等等， CPU 更多的是处于等待， I/O
部分称为程序性能的瓶颈。
3. 程序之间相互等待，结果 CPU 利用率很低，但运行速度依然很慢，事务间的共享
与死锁制约了程序的性能。

### proc

#### `cat /proc/stat`

cpu 5116 0 7801 249195 60 41 55

单位： 1jiffies=0.01秒
user（ 5116）：从系统启动开始累计到当前时刻，用户态的 CPU 时间，不包含 nice 值为负的
进程。
nice（ 0）：从系统启动开始累计到当前时刻， nice 值为负的进程所占用的 CPU 时间。
system(7801)：从系统启动开始累计到当前时刻，内核所占用的 CPU 时间。
idle(259195)：从系统启动开始累计到当前时刻，除硬盘 IO 等待时间以外其它等待时间。
iowait(60)：从系统启动开始累计到当前时刻，硬盘 IO 等待时间。
irq（ 41）：从系统启动开始累计到当前时刻，硬中断时间。
softirq（ 55）：从系统启动开始累计到当前时刻，软中断时间。
CPU 时间=user+system+nice+idle+iowait+irq+softirq

**CPU 的利用率=1-（ idle） /（ user+system+nice+idle+iowait+irq+softirq）**

1. 我们程序代码有问题，导致占用了大量的 CPU，我们可以通过
CPU 用户态利用率=(user+nice)/(user+system+nice+idle+iowait+irq+softirq）。
来了解。
2. 我们程序代码调用了大量的系统调用，导致 Linux 内核占用了大量的 CPU，我们可以通
过
CPU 内核态利用率=（ system） /（ user+system+nice+idle+iowait+irq+softirq）。
来了解。
3. 系统和 FLASH、内存等有大量的交互和等待，从而导致系统性能下降，我们可以通过
IO 利用率=(iowait)/（ user+system+nice+idle+iowait+irq+softirq）
来了解。

#### `cat /proc/loadavg`

0.64 0.53 0.43 3/121 482
loadavg 主要检查当前的系统的负载情况。
0.64 1-分钟平均负载
0.53 5-分钟平均负载
0.43 15-分钟平均负载
3 在采样时刻，运行队列的任务的数目，与/proc/stat 的 procs_running 表示相同意思
121 在采样时刻，系统中活跃的任务的个数（不包括运行已经结束的任务）
482 最大的 pid 值，包括轻量级进程，即线程