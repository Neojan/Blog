![image](https://github.com/user-attachments/assets/6cb62b3e-6330-42ad-9c89-f953a5711620)
## 架构设计过程

### 洞察节奏：3个原则

· 【原则1】 看透需求
· 【原则2】 架构大方向正确
· 【原则3】 设计好架构的各个方面

### 掌握过程：6个步骤

- 需求分析
- 领域建模
- 确定关键需求
- 概念架构设计
- 细化架构设计
- 架构验证

### 需求分析

需求分析活动输出的“需求”，必须涵盖功能、质量、约束这三个方面

· 【一纵】 需求沟通
· 【二纵】 非功能需求的确定。
· 【三横】 需求分析主线。从确定系统目标开始，后续凭借“范围+Feature+上下文图”三剑客研究高层需求，再后续建立开发人员较熟悉的用例模型。
![image](https://github.com/user-attachments/assets/4097d041-6ead-4a81-88d2-5bb221ba8af3)


### 领域建模

领域模型，就是将领域概念（即领域行话）以可视化的方式抽象成一个或一套模型。对比而言，领域模型比《领域词汇表》更进了一步，它不仅关注重要的领域概念，更重要的是它还刻画领域概念之间的关系。

领域建模，是以提炼领域概念，建立领域模型为目的的活动。领域建模实践的精髓是“业务决定功能，功能决定模型”。

领域建模活动的输入：一是“功能”，二是“可扩展性”具体要求。

### 确定关键需求

为了确定“关键功能”，一要关注“功能需求”，二要研究“约束需求”；为了确定“关键质量”，一要关注“质量需求”，二要研究“约束需求”。

### 概念架构设计

所谓概念架构，是直指系统目标的设计思想、重大选择。“直指目标”说的是输入，“设计思想和重大选择”说的是输出。
![image](https://github.com/user-attachments/assets/38a56977-8979-40dc-bf8f-ef2395b926fa)


### 细化架构设计

细化架构和概念架构的关键区别之一是：概念架构没有设计到“模块+接口”一级，而细化架构必须关注“模块+接口”。

#### 细化架构设计的“技能项”——15个设计任务

![image](https://github.com/user-attachments/assets/a7251211-cb39-483e-a250-52347dbb1478)


### 架构验证

架构验证的输出成果是“架构原型”。和一般的开发不同，架构原型的开发不是要完美地、无 Bug 地实现功能，而是在“细化架构”的总体指导下，仅把存在“风险”的那些设计尽早开发出来，然后通过执行测试等手段判断“风险”是否解决。

## 概念架构

### 概念架构是什么

概念架构是直指目标的设计思想、重大选择。

概念架构，英文是Conceptual Architecture。至于概念架构的定义，Dana Brede meyer等专家是这么阐释的：
概念架构界定系统的高层组件、以及它们之间的关系。概念架构意在对系统进行适当分解、而不陷入细节。借此，可以与管理人员、市场人员、用户等非技术人员交流架构。概念架构规定了每个组件的非正式规约、以及架构图，但不涉及接口细节。

### 左手功能——概念架构设计

概念架构设计环节的输入，一是关键功能、二是关键质量。形象地说，叫左手功能、右手质量，两手抓，两手都要硬。

#### 鲁棒图

鲁棒图（Robustness Diagra m）是由Ivar Jacobson于1991年发明的，用以回答“每个用例需要哪些对象”的问题。“鲁棒”图 != “鲁棒性”。“鲁棒图（Robustness Di agram）”的作用，除了初步设计之外，就是检查用例规约是否正确和完善了。

鲁棒图包含3种元素（如图9-10所示），它们分别是边界对象、控制对象、实体对象：

· 边界对象对模拟外部环境和未来系统之间的【交互】 进行建模。边界对象负责接收外部输入、处理内部内容的解释、并表达或传递相应的结果。
· 控制对象对【行为】 进行封装，描述用例中事件流的控制行为。
· 实体对象对【信息】 进行描述，它往往来自领域概念，和领域模型中的对象有良好的对应关系。

![image](https://github.com/user-attachments/assets/cb309c49-be3d-4175-ad10-a6dcd5a0b739)


网上书店“按作者名搜索图书”功能运用增量建模技巧进行鲁棒图建模。

![image](https://github.com/user-attachments/assets/b3a25dc7-8492-4ce9-8593-44d03bcb12f6)


### 右手质量——概念架构设计

越过从质量需求到设计的鸿沟，需要搭桥。这“桥”就是下面要讲的场景技术，其关键是使笼统的非功能目标明确化。

![image](https://github.com/user-attachments/assets/00ae95e0-66a3-4453-b3cc-983c8f7f16f7)


本书建议场景应包含5要素：
· 影响来源。来自系统外部或系统内部的触发因素。
· 如何影响。影响来源施加了什么影响。
· 受影响对象。默认的受影响对象为“本系统”。
· 问题或价值。受影响对象因此而出现什么问题，或需要体现什么价值。
· 所处环境。此时，所处的环境或上下文怎样。（此要素为可选要素）

#### 场景思维的工具

如果需要，可以借助“场景卡”这种工具，来收集有用的场景——当需求分析师并未通过场景技术明确定义非功能需求，当架构师也深感难以到位地发现有价值的场景，这时候架构师可以借助于场景卡来激活团队的力量，让大家提交场景。

![image](https://github.com/user-attachments/assets/447a9330-41b5-4c6f-aa6a-51f745e885ae)


目标—场景—决策表（如图 9-21 所示）是另一种极其有用的思维工具，熟练掌握大有必要。借助这种思维工具，我们的思考过程形象化、可视化。如果说场景卡是“关键点”（用于识别场景），那么目标—场景—决策表就是“纵贯线”（用于打通思维）。

运用目标—场景—决策表针对质量进行设计时，“不支持该场景”恰恰是一种有价值的决策——如果每个场景都支持，理性设计就无从谈起、多度设计就在所难免了。这就要求我们在实践时，必须对场景进行评估，以决定是否支持这个场景。如图 9-22 所示，架构师经常要考虑的场景评估因素包括：价值大小、代价大小、开发难度高低、技术趋势、出现几率等。

![image](https://github.com/user-attachments/assets/817831fc-4835-4c70-8f9d-f0c3eddc637e)



![image](https://github.com/user-attachments/assets/1aa423b8-22c1-46d6-ba43-fb432b04fb3c)


### 概念架构设计实践要领

- 要领1：功能需求与质量需求并重
- 要领2：概念架构设计的1个决定、4个选择
    · 决定：如何划分顶级子系统。
    · 选择：架构风格选型，开发技术选型，二次开发技术选型，集成技术选型。



- 要领3：备选设计

![image](https://github.com/user-attachments/assets/3298cccc-f353-4045-b232-333f9b6bb530)


## 细化架构

### 2视图

逻辑架构：规定了软件系统由哪些逻辑元素组成以及这些逻辑元素之间的关系。具体而言，组成软件系统的逻辑元素可以是逻辑层（Layer）、功能子系统、模块。设计逻辑架构的核心任务，是比较全面地识别模块、规划接口，并基于此进一步明确模块之间的使用关系和使用机制。

物理架构：规定了组成软件系统的物理元素，这些物理元素之间的关系，以及它们部署到硬件上的策略。

![image](https://github.com/user-attachments/assets/f38165eb-96fb-4618-95b4-31ec44a7d3d6)


![image](https://github.com/user-attachments/assets/6530a8dc-01ac-4be3-8245-76dea91480ee)

### 5视图

在软件架构设计中，"5视图模型"是一种从不同视角描述系统架构的框架，旨在帮助全面理解和分析复杂系统。
5视图方法：每个视图，一组技术关注点

![image](https://github.com/user-attachments/assets/e966e5ef-8d45-4a04-835e-9c57d319e3bd)


### 逻辑架构
规定了软件系统由哪些逻辑元素组成以及这些逻辑元素之间的关系

三大核心任务
- 识别功能块
- 规划功能块的接口
- 明确功能块之间的使用关系和使用机制

### 物理架构

规定了组成软件系统的物理元素，这些物理元素之间的关系，以及它们部署到硬件上的策略

---

### 1. **逻辑架构视图（Logical View）**

- **关注点**：系统的功能需求，即"做什么"。
- **内容**：
    - 功能模块划分（组件、类、接口等）。
    - 模块间的交互关系（如UML类图、序列图）。
    - 面向对象设计中的领域模型。
- **目标**：确保系统功能被正确拆解和实现。

---

### 2. **开发架构视图（Development View）**

- **关注点**：开发阶段的代码组织和实现。
- **内容**：
    - 代码结构（包、模块、库的划分）。
    - 编译依赖关系（如Maven/Gradle配置）。
    - 开发工具链和技术栈选择。
- **目标**：支持团队协作和代码维护。

---

### 3. **运行架构视图（Process View/Runtime View）**

- **关注点**：系统运行时行为。
- **内容**：
    - 进程/线程的并发、同步、通信机制。
    - 动态交互（如微服务调用链路、消息队列）。
    - 容错和负载均衡策略。
- **目标**：保证性能和可靠性。

---

### 4. **物理架构视图（Physical View/Deployment View）**

- **关注点**：硬件和基础设施部署。
- **内容**：
    - 服务器、网络拓扑、数据中心布局。
    - 部署单元（如容器、虚拟机）分布。
    - 高可用和灾备方案（如集群、CDN）。
- **目标**：映射软件到硬件环境。

---

### 5. **数据架构视图（Data View）**

- **关注点**：数据的存储、流动和管理。
- **内容**：
    - 数据库设计（关系型/NoSQL）。
    - 数据流（ETL、API数据传输）。
    - 数据安全与备份策略。
- **目标**：保障数据一致性、完整性和访问效率。

---

### 补充说明

- **Philippe Kruchten的4+1视图**：与此类似，但包含场景视图（用例驱动其他视图）。
- **实际应用**：不同视图可能重叠，需根据项目需求调整（如IoT系统可能强调物理视图，大数据系统侧重数据视图）。
- **工具示例**：C4模型、ArchiMate等可辅助绘制多视图。


## 4+1视图

“4+1”架构视图模型是经典的软件架构描述方法，由Philippe Kruchten提出，用于从不同视角系统性描述复杂系统的架构。

---

### 1. 「4+1」视图的组成

通过5个互补的视角描述系统架构，其中**4个核心视图**服务于不同角色，**+1场景视图**验证架构有效性：

| 视图       | 受众      | 描述重点       | 典型产出物      |
| -------- | ------- | ---------- | ---------- |
| **逻辑视图** | 分析师/设计师 | 功能模块划分、类关系 | UML类图、包图   |
| **开发视图** | 开发人员    | 代码组织、编译依赖  | 模块结构图、组件图  |
| **流程视图** | 系统集成人员  | 运行时进程/线程交互 | 序列图、状态机图   |
| **物理视图** | 运维人员    | 服务器部署、网络拓扑 | 部署图、基础设施图  |
| **场景视图** | 所有利益相关者 | 关键用例的端到端实现 | 用户故事、交互流程图 |
[软件架构的“4+1”视图模型](https://blog.csdn.net/hyde_jiang/article/details/129776717 )
https://developer.aliyun.com/article/1256019
## 模块划分

模块划分：功能模块、分层架构、用例驱动的模块划分
![image](https://github.com/user-attachments/assets/0a9ca660-a3e9-45a8-9301-10152fef711f)


## 分层架构

### 常见模式：展现层、业务层、数据层

![image](https://github.com/user-attachments/assets/fceed952-23c3-4078-b109-47cdc62b8ec7)


### 常见模式：UI层、SI层、PD层、DM层

· UI层，即用户界面层（User Interface）。负责封装与用户的双向交互、屏蔽具体交互方式。
· SI层，即系统交互层（System Interaction）。负责封装硬件的具体交互方式，以及封装外部系统的交互。
· PD 层，即问题领域层（Problem Do main）。负责问题领域或业务领域的抽象、领域功能的实现。
· DM 层，即数据管理层（Data Man agement）。负责封装各种持久化数据的具体管理方式，例如数据库系统、二进制文件、文本文档、XML文档、Flash存储结构。

![image](https://github.com/user-attachments/assets/a2c85f55-be9a-495b-862d-07a09ae00dc7)


### 总结

确定分层架构之后，还需要进行细粒度的模块划分，手段有多种，但思想都是“封装”：
· 经典的 3 层架构、4 层架构，投标可能够用，但指导后续详细设计和并行开发绝对不够，还需要通过引入Sub-layer进行【分层的细化】。
· 根据功能树划分粗粒度的“功能模块”（纵切）和现有分层架构（横切）并不矛盾，为了引入这一维度的切分，还需要【分区】。
· 为了将软件系统的通用部分和专用部分相分离，便于重用或提炼程序库（Library）或框架（Framework），还需要【通用模块的分离】和【通用机制的框架化】



