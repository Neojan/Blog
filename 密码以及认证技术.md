# 介绍

加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 不需要密钥 的 散列算法。另外，还有结合对称和非对称加密的混合加密算法。

常见的 对称加密 算法主要有 DES、3DES、AES 等，常见的 非对称算法 主要有RSA、DSA 等，散列算法 主要有HMAC、SHA-1、MD5 等。

## 对称加密算法

对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。

AES、DES、3DES 都是 对称 的 块加密算法，加解密 的过程是 可逆的。常用的有 AES128、AES192、AES256。

AES是当前最常用的对称加密算法。

### 分组加密模式

DES，AES都属于分组加密技术，即只能加密固定长度的明文，如果需要加密任意长度的明文，就需要对分组加密进行迭代，而分组加密的迭代方法就称为分组加密的“模式”。DES,3DES的分组长度是64bit，AES是128bit。

种类:ECB, CBC, CFB, OFB, CTR，需要理解各种模式的优缺点，建议使用CBC和CTR模式

### AES

AES （Advanced Encryption Standard）高级加密标准。Rijndael算法首先是一个密钥分组加密的算法，通过置换（permutations ）和替换(substitutions）迭代加密，进过多轮操作形成密文。AES算是Rijndael算法的一种特殊实现，选的分组为128bit（16bytes），密钥可以使用128、192 和 256bit三种。密钥越长，安全强度越高，但伴随运算轮数的增加，带来的运算开销就会更大.

### DES

DES 加密算法是一种 分组密码，以 64 位为 分组对数据 加密，它的 密钥长度 是 56 位，加密解密用同一算法。

DES 加密算法是对 密钥 进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 搜索密钥的编码。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 2 ^ 56 次。

安全性：DES已经能够短时间被暴力破解，不建议使用。

### 3DES算法

triple-DES: 是基于 DES 的 对称算法，对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。密钥长度56 x 3 = 168bit

安全性：只是DES的过渡加密标准，处理速度不高，安全性也逐渐显现一些问题，实际项目选取加密算法时，不考虑。

## 非对称加密算法

非对称加密算法，又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。

因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。

非对称加密主要解决对称加密中的密钥配对问题：
- 通过事先共享密钥来解决
- 通过密钥分配中心来解决
- 通过Diffie-Hellman密钥交换来解决
- 通过非对称加密技术来解决

公钥加密，私钥解密的作用是加密信息。因为只有拥有私钥的人才可以获取信息明文。

私钥加密，公钥解密的作用是身份认证。因为只有拥有私钥的人才可以发送信息密文。

### RSA

RSA：可用于非对称加密与数字签名。

> RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。

密钥对： 公钥：数E 和 数N， 私钥：数D 和 数N
加密：密文 = 明文 E mod N （明文的E次方除以N的余数）
解密：明文 = 密文 D mod N （密文的D次方除以N的余数）

RSA算法密钥长度的选取直接关系到加解密、签名验签的安全强度和运算速度。密钥的长度实际上是指公钥模N的长度（以Bit为单位），理论上来讲N越大，安全强度越高，算法运算速度越慢。现有RSA1024(不建议使用),RSA-2048,RSA-3072,RSA-4096

RSA几个特性如下：
- 密钥长度增长一倍，公钥操作所需时间增加约4倍，私钥操作所需时间增加约8倍，公私钥生成时间约增长16倍。
- 一次能加密的密文长度与公钥长度成正比，如RSA1024，一次能加密的内容长度为 1024/8 = 128bytes（包含填充字节）。所以非对称加密一般都用于加密对称加密算法的密钥，而不是直接加密内容。
- 加密后密文的长度为公钥的长度，例如公钥长度为1024Bit(128Byte)，最后生成的密文固定为 1024bit(12bytes)。

## 混合加密

在交换密钥的环节使用非对称加密，之后的通信则使用对称加密。

用 对称加密 加密 待发送数据

用非对称加密技术加密对称加密算法中使用的会话密钥

用伪随机数生成器生成对称加密中的会话密钥

### 应用

传输大量数据的时候使用对称加密，因为加解密速度快。但是由于对称加密有秘钥分配问题，所以我们用非对称加密来加密这个对称密钥再传递给对方。

我们会认为接下来的方案应该是比较完美了吧？

双向通信之前要先把公钥相互交换，比如A和B要通信

A：这是我的公钥public_A，你收好，你生成对称密钥也给我一下

B：好的，收到public_A，你收好对称密钥secretKey。然后用public_A加密这个secretKey

A：收到消息，private_A解密出来是secretKey

这就解决了对称密钥secretKey的密钥分配问题，然后双方就可以用secretKey加密消息进行通信了

### 中间人攻击

A：这是我的公钥public_A，你收好，你生成对称密钥也给我一下

X获得了A的公钥，把自己的公钥public_X发给B… B这傻子还以为真的是A的公钥呢

B：好的，公钥public_X已收到，生成一个对称密钥secretKey，然后用public_X加密这个对称密钥。

X截获了这个消息，用自己私钥private_X解密出对称密钥secretKey，自己再生成一个secretKeyXXX用public_A加密一下发送给A。A这傻子还以为你们接下来会安全的用secretKey通信吗哈哈哈

A：收到消息，private_A解密出来对称密钥secretKeyXXX（其实是X篡改了）

### 重放攻击（Replay Attack）

攻击者会在通信中拦截到合法用户的数据包，并将其重放回网络中，以欺骗服务器或其他合法用户。重放攻击一般用于攻击需要进行认证、授权、加密等安全操作的系统，如金融交易系统、远程登录系统等。

攻击者通过重复发送之前的请求或响应数据包，试图绕过系统的安全控制。这种攻击方式很容易实施，因为攻击者只需要捕获合法用户的通信流量，并重新发送相同的数据包。重放攻击可以导致很多问题，例如：未经授权的数据访问、恶意数据篡改、信息泄漏等。

避免方法

- 加密通信数据：加密通信数据可以防止攻击者截获数据包，并且即使攻击者截获了数据包，也无法轻易地理解数据。
- 时间戳：服务器可以使用时间戳来检测是否发生了重放攻击。时间戳是一个数字，可以帮助服务器检测是否在一定时间内重复接收到同样的请求。
- 挑战-响应认证：挑战-响应认证是一种身份验证机制，服务器通过这种机制向客户端发送一个随机数（挑战），然后客户端必须用客户端的身份验证信息对该随机数进行加密，并将结果发送回服务器（响应）。服务器检查该响应是否与预期的响应匹配，以此来验证客户端身份，从而避免重放攻击。
- 使用序列号及令牌：针对客户端发起多次相同请求的情况，可以给请求生成唯一的令牌或序列号，并将令牌或序列号记录在服务器上，确保服务器只接收一次有效请求。
- 使用防重放机制：防重放机制是一种安全措施，可以检测和防止重放攻击。在实现防重放机制时，通常会使用数字签名、哈希函数、时间戳等技术，从而确保数据包的唯一性和完整性，从而避免攻击者能够进行重放攻击。

## 常见的签名算法

### MD5算法

MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。

### SHA1算法

SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。

### SHA-2（Secure Hash Algorithm 2）推荐

前两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。 目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。

SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

### HMAC算法

HMAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。

HMAC的MAC算法是hash算法，它可以是MD5, SHA-1或者 SHA-256，他们分别被称为HMAC-MD5，HMAC-SHA1， HMAC-SHA256。

HMAC 发送方 和 接收方 都有的 key 进行计算，而没有这把 key 的第三方，则是 无法计算 出正确的 散列值的，这样就可以 防止数据被篡改。

## 常见登陆验证方式

### RSA+AES128

- 服务端：获取一个随机串，设计思路，如 随机串 = MD5(当前时间+/dev/random + ip + ...等)
- 服务端：RSA公钥加密 随机串，发送给客户端
- 客户端：使用HMAC(用户名+挑战串)生成摘要，HMAC(密码+挑战串)生成摘要，返回给服务端
- 服务端：分别验证用户名的摘要和密码的摘要，确认是否登陆成功，登陆成功，记录USER-ID，后续通信验证USER-ID
- 服务端：维持一个USER-ID时效性判定和登陆锁定等流程，定期判定USER-ID是否有效或锁定，失效则需要客户端重新登陆验证，锁定则不允许登陆。

### Session + Cookies

服务器需要保存SessionID, 登陆过多就需要存储大量的SessionID，可拓展性较差。

- 客户端：使用用户名和口令登陆
- 服务端：验证用户名和口令，如果验证通过，生成sessionID(每个登陆者不一样)，通过cookie返回给客户端
- 客户端利用sessionID访问服务端
- 服务端对返回的sessionID进行验证（是否超时，是否已经记录）。
- 登出：客户端退出登陆，服务端删除此sessionID，后续就不能用此sessionID请求了。


### Token

- 客户端：使用用户名和口令登陆
- 服务端：验证用户名和口令，如果验证通过，签发Token，返回给客户端
- 客户端后续使用Token进行请求（客户端存储Token），服务器一般根据Header和UserId计算出Token，然后进行验证（以时间换空间）。

Token的使用可以参考JWT(JSON Web Tokens)标准 : 头部（header）, 数据（payload）和签名（signature）。

- header：`{"typ": "JWT","alg": "HS256"}`，typ”键的值指定对象是JWT，“alg”键的值指定用于创建 JWT 签名的算法。 HS256表示使用HMAC-SHA256算法来计算签名。
- payload: `{"userId": "abcdefg","iat":1234567890}`
> JWT 规定了7个官方字段，供选用。
  iss (issuer)：签发人
  exp (expiration time)：过期时间
  sub (subject)：主题
  aud (audience)：受众
  nbf (Not Before)：生效时间
  iat (Issued At)：签发时间
  jti (JWT ID)：编号
  除了官方字段，你还可以在这个部分定义私有字段。请记住，数据的大小将影响JWT的总体大小，这通常不是问题，但过大的 JWT 可能会对性能产生负面影响并导致延迟。

- signature：签名则通过服务端私有的key计算而成，实例如下：

key = 'secretkey' 
unsignedToken = encodeBase64(header) + '.' + encodeBase64(payload) 
signature = HMAC-SHA256(key, unsignedToken)

- Token由上面三部分Base64编码后拼接生成，中间用点分隔开：Token = encodeBase64(header) + '.' + encodeBase64(payload) + '.' + encodeBase64(signature)。

### 数字证书

简而言之，数字证书由CA的数字签名和服务器的公钥组成

派发给客户端的数字证书 会被CA的私钥加密，只有CA的公钥才能解密。解决了非对称加密中的密钥分配问题。

数字证书（Public Key Certificate，PKC），虽然我习惯叫它”证书“，但是我们从它的英文名称可以看出来它原来的全称叫做“公钥证书”，这就好理解了，它的存在其实就是为了用来证明公钥的可靠性，其实它就像我们的”身份证“一样，既可以证明我们身份的真实可靠，也具有防伪的功能及权威性。

证书认证机构（Certification Authority，CA），顾名思义，这就是认证且颁发证书的机构。刚刚在描述证书的时候用我们的身份证来做了个比喻，接着用这个例子的话，那证书认证机构就相当于“公安局”，这个机构具有一定的权威性和可靠性，因此进而保证了证书的可靠性，最终就可以最大限度的实现公钥的真实可靠。

### 摘要认证

摘要认证的基本原则就是绝不通过网络发送明文密码，而是发送一个密码的摘要信息来取代密码，并且这个摘要信息是不可逆的。摘要认证主要关注数据完整性验证。

最常见的就是HTTP认证的摘要认证(Digest)，RTSP中也用到了HTTP摘要认证。

客户端GET -> 服务器返回401 Unauthorized 并带上 WWW-Authenticate（包括Digest，realm，qop，nonce，stale等）-> 客户端计算后重新发起GET请求，头部填入Authorization（包括Digest，realm，qop，uri，nonce，response，cnonce等） -> 服务器验证Authorization信息，成功后返回200 OK

- WWW-Authentication：用来定义使用何种方式（Basic、Digest、Bearer等）去进行认证以获取受保护的资源
- realm：表示Web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码
- qop：保护质量，包含auth（默认的）和auth-int（增加了报文完整性检测）两种策略，（可以为空，但是）不推荐为空值
- nonce：服务端向客户端发送质询时附带的一个随机数，这个数会经常发生变化。客户端计算密码摘要（没指定默认MD5）时将其附加上去，使得多次生成同一用户的密码摘要各不相同，用来防止重放攻击
- nc：nonce计数器，是一个16进制的数值，表示同一nonce下客户端发送出请求的数量。例如，在响应的第一个请求中，客户端将发送“nc=00000001”。这个指示值的目的是让服务器保持这个计数器的一个副本，以便检测重复的请求
- cnonce：客户端随机数，这是一个不透明的字符串值，由客户端提供，并且客户端和服务器都会使用，以避免用明文文本。这使得双方都可以查验对方的身份，并对消息的完整性提供一些保护
- response：这是由用户代理软件计算出的一个字符串，以证明用户知道口令
- Authorization-Info：用于返回一些与授权会话相关的附加信息
- nextnonce：下一个服务端随机数，使客户端可以预先发送正确的摘要
- rspauth：响应摘要，用于客户端对服务端进行认证
- stale：当密码摘要使用的随机数过期时，服务器可以返回一个附带有新随机数的401响应，并指定stale=true，表示服务器在告知客户端用新的随机数来重试，而不再要求用户重新输入用户名和密码了

response 计算方式有多种，客户端和服务端选择一致的即可。response = MD5(MD5(username:realm:password):nonce:nc:cnonce:qop:MD5(<request-method>:url))

#### 总结
在HTTP中，摘要认证是一种身份验证机制，用于验证客户端和服务器之间的通信身份，并确保传输的数据完整性。它提供了一种相对安全的方式来验证用户的身份，防止密码等敏感信息在传输过程中被窃听或篡改。

摘要认证的作用包括：

1. 身份验证：摘要认证允许客户端向服务器发送身份凭据进行身份验证。客户端发送的身份凭据是经过摘要算法处理的哈希值，而不是明文密码，从而增加了安全性。

2. 数据完整性：摘要认证使用哈希函数来生成摘要，这个摘要与请求中的其他信息一起发送到服务器。服务器可以通过重新计算摘要并将其与接收到的摘要进行比较，来验证数据在传输过程中是否完整、未被篡改。

3. 抗重放攻击：摘要认证可以防止重放攻击，其中攻击者截获合法请求的摘要并再次发送给服务器，试图通过重播原始请求来获得未经授权的访问。通过在摘要中包含随机数或时间戳等信息，摘要认证可以防止重放攻击。

总而言之，摘要认证在HTTP中的作用是通过身份验证和数据完整性验证来确保通信的安全性。它提供了一种相对较强的身份验证机制，并防止数据被篡改或重放攻击。


### 挑战串-挑战应答方式：challenge-response

主要用于身份验证

#### 认证过程

顾名思义，基于挑战/应答（Challenge/Response）方式的身份认证系统就是每次认证时认证服务器端都给客户端发送一个不同的"挑战"字串，客户端程序收到这个"挑战"字串后，做出相应的"应答",以此机制而研制的系统.认证过程为：

- 客户向认证服务器发出请求，要求进行身份认证；
- 认证服务器从用户数据库中查询用户是否是合法的用户，若不是，则不做进一步处理；
- 认证服务器内部产生一个随机数，作为"提问"，发送给客户；
- 客户将用户名字和随机数合并，使用单向Hash函数（例如MD5,HMAC算法）生成一个字节串作为应答；
- 认证服务器将应答串与自己的计算结果比较，若二者相同，则通过一次认证；否则，认证失败；
- 认证服务器通知客户认证成功或失败。
- 以后的认证由客户不定时地发起，过程中没有了客户认证请求一步。两次认证的时间间的密钥隔不能太短，否则就给网络、客户和认证服务器带来太大的开销；也不能太长，否则不能保证用户不被他人盗用IP地址，一般定为1-2分钟。
