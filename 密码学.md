# 介绍

加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 不需要密钥 的 散列算法。另外，还有结合对称和非对称加密的混合加密算法。

常见的 对称加密 算法主要有 DES、3DES、AES 等，常见的 非对称算法 主要有RSA、DSA 等，散列算法 主要有HMAC、SHA-1、MD5 等。

## 对称加密算法

对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。

AES、DES、3DES 都是 对称 的 块加密算法，加解密 的过程是 可逆的。常用的有 AES128、AES192、AES256。

AES是当前最常用的对称加密算法。

### 分组加密模式

DES，AES都属于分组加密技术，即只能加密固定长度的明文，如果需要加密任意长度的明文，就需要对分组加密进行迭代，而分组加密的迭代方法就称为分组加密的“模式”。DES,3DES的分组长度是64bit，AES是128bit。

种类:ECB, CBC, CFB, OFB, CTR，需要理解各种模式的优缺点，建议使用CBC和CTR模式

### AES

AES （Advanced Encryption Standard）高级加密标准。Rijndael算法首先是一个密钥分组加密的算法，通过置换（permutations ）和替换(substitutions）迭代加密，进过多轮操作形成密文。AES算是Rijndael算法的一种特殊实现，选的分组为128bit（16字节），密钥可以使用128、192 和 256bit三种。

### DES

DES 加密算法是一种 分组密码，以 64 位为 分组对数据 加密，它的 密钥长度 是 56 位，加密解密用同一算法。

DES 加密算法是对 密钥 进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 搜索密钥的编码。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 2 ^ 56 次。

安全性：DES已经能够短时间被暴力破解，不建议使用。

### 3DES算法

triple-DES: 是基于 DES 的 对称算法，对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。密钥长度56 x 3 = 168bit

安全性：只是DES的过渡加密标准，处理速度不高，安全性也逐渐显现一些问题，实际项目选取加密算法时，不考虑。

## 非对称加密算法

非对称加密算法，又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。

因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。

非对称加密主要解决对称加密中的密钥配对问题：
- 通过事先共享密钥来解决
- 通过密钥分配中心来解决
- 通过Diffie-Hellman密钥交换来解决
- 通过非对称加密技术来剞劂

### RSA

RSA：可用于非对称加密与数字签名。

> RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。

密钥对： 公钥：数E 和 数N， 私钥：数D 和 数N
加密：密文 = 明文 E mod N （明文的E次方除以N的余数）
解密：明文 = 密文 D mod N （密文的D次方除以N的余数）

## 混合加密

在交换密钥的环节使用非对称加密，之后的通信则使用对称加密。

用 对称加密 加密 待发送数据

用非对称加密技术加密对称加密算法中使用的会话密钥

用伪随机数生成器生成对称加密中的会话密钥

用白话来讲：非对称加密为了解决密钥协商问题，对称加密由于计算量少、快速，因此用于后续通信。

### 应用

传输大量数据的时候使用对称加密，因为加解密速度快。但是由于对称加密有秘钥分配问题，所以我们用非对称加密来加密这个对称密钥再传递给对方。

我们会认为接下来的方案应该是比较完美了吧？

双向通信之前要先把公钥相互交换，比如A和B要通信

A：这是我的公钥public_A，你收好，你生成对称密钥也给我一下

B：好的，收到public_A，你收好对称密钥secretKey。然后用public_A加密这个secretKey

A：收到消息，private_A解密出来是secretKey

这就解决了对称密钥secretKey的密钥分配问题，然后双方就可以用secretKey加密消息进行通信了

### 中间人攻击

A：这是我的公钥public_A，你收好，你生成对称密钥也给我一下

X获得了A的公钥，把自己的公钥public_X发给B… B这傻子还以为真的是A的公钥呢

B：好的，公钥public_X已收到，生成一个对称密钥secretKey，然后用public_X加密这个对称密钥。

X截获了这个消息，用自己私钥private_X解密出对称密钥secretKey，自己再生成一个secretKeyXXX用public_A加密一下发送给A。A这傻子还以为你们接下来会安全的用secretKey通信吗哈哈哈

A：收到消息，private_A解密出来对称密钥secretKeyXXX（其实是X篡改了）

### 重放攻击（Replay Attack）

攻击者会在通信中拦截到合法用户的数据包，并将其重放回网络中，以欺骗服务器或其他合法用户。重放攻击一般用于攻击需要进行认证、授权、加密等安全操作的系统，如金融交易系统、远程登录系统等。

攻击者通过重复发送之前的请求或响应数据包，试图绕过系统的安全控制。这种攻击方式很容易实施，因为攻击者只需要捕获合法用户的通信流量，并重新发送相同的数据包。重放攻击可以导致很多问题，例如：未经授权的数据访问、恶意数据篡改、信息泄漏等。

避免方法

- 加密通信数据：加密通信数据可以防止攻击者截获数据包，并且即使攻击者截获了数据包，也无法轻易地理解数据。
- 时间戳：服务器可以使用时间戳来检测是否发生了重放攻击。时间戳是一个数字，可以帮助服务器检测是否在一定时间内重复接收到同样的请求。
- 挑战-响应认证：挑战-响应认证是一种身份验证机制，服务器通过这种机制向客户端发送一个随机数（挑战），然后客户端必须用客户端的身份验证信息对该随机数进行加密，并将结果发送回服务器（响应）。服务器检查该响应是否与预期的响应匹配，以此来验证客户端身份，从而避免重放攻击。
- 使用序列号及令牌：针对客户端发起多次相同请求的情况，可以给请求生成唯一的令牌或序列号，并将令牌或序列号记录在服务器上，确保服务器只接收一次有效请求。
- 使用防重放机制：防重放机制是一种安全措施，可以检测和防止重放攻击。在实现防重放机制时，通常会使用数字签名、哈希函数、时间戳等技术，从而确保数据包的唯一性和完整性，从而避免攻击者能够进行重放攻击。

### 摘要认证

最常见的就是HTTP认证的摘要认证(Digest)

客户端GET -> 服务器返回401 Unauthorized 并带上 WWW-Authenticate（包括Digest，realm，qop，nonce，stale等）-> 客户端计算后重新发起GET请求，头部填入Authorization（包括Digest，realm，qop，uri，nonce，response，cnonce等） -> 服务器验证Authorization信息，成功后返回200 OK

- WWW-Authentication：用来定义使用何种方式（Basic、Digest、Bearer等）去进行认证以获取受保护的资源
- realm：表示Web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码
- qop：保护质量，包含auth（默认的）和auth-int（增加了报文完整性检测）两种策略，（可以为空，但是）不推荐为空值
- nonce：服务端向客户端发送质询时附带的一个随机数，这个数会经常发生变化。客户端计算密码摘要（没指定默认MD5）时将其附加上去，使得多次生成同一用户的密码摘要各不相同，用来防止重放攻击
- nc：nonce计数器，是一个16进制的数值，表示同一nonce下客户端发送出请求的数量。例如，在响应的第一个请求中，客户端将发送“nc=00000001”。这个指示值的目的是让服务器保持这个计数器的一个副本，以便检测重复的请求
- cnonce：客户端随机数，这是一个不透明的字符串值，由客户端提供，并且客户端和服务器都会使用，以避免用明文文本。这使得双方都可以查验对方的身份，并对消息的完整性提供一些保护
- response：这是由用户代理软件计算出的一个字符串，以证明用户知道口令
- Authorization-Info：用于返回一些与授权会话相关的附加信息
- nextnonce：下一个服务端随机数，使客户端可以预先发送正确的摘要
- rspauth：响应摘要，用于客户端对服务端进行认证
- stale：当密码摘要使用的随机数过期时，服务器可以返回一个附带有新随机数的401响应，并指定stale=true，表示服务器在告知客户端用新的随机数来重试，而不再要求用户重新输入用户名和密码了

response 计算方式有多种，客户端和服务端选择一致的即可。response = MD5(MD5(username:realm:password):nonce:nc:cnonce:qop:MD5(<request-method>:url))

## 常见的签名算法

### MD5算法

MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。

### SHA1算法

SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。

### SHA-2（Secure Hash Algorithm 2）推荐

前两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。 目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。

SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

### HMAC算法

HMAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。

HMAC 发送方 和 接收方 都有的 key 进行计算，而没有这把 key 的第三方，则是 无法计算 出正确的 散列值的，这样就可以 防止数据被篡改。

## 数字证书

简而言之，数字证书由CA的数字签名和服务器的公钥组成
派发给客户端的数字证书 会被CA的私钥加密，只有CA的公钥才能解密。解决了非对称加密中的密钥分配问题。
